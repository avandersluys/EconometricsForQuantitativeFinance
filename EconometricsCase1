# Econometrics Case 1

# Libraries
import pandas as pd
import numpy as np 
import statsmodels.api as sm
import matplotlib.pyplot as plt
from pathlib import Path
import warnings
from scipy.stats import chi2 #for hausman test
from linearmodels.panel import RandomEffects

warnings.filterwarnings(
    "ignore",
    category=RuntimeWarning,
    module=r"linearmodels\.panel\..*"
)

# Base URL for raw GitHub repo
BASE_URL = "https://raw.githubusercontent.com/avandersluys/EconometricsForQuantitativeFinance/main"

# Loading datasets directly from GitHub
df_ff = pd.read_csv(f"{BASE_URL}/capmff_2010-2025_ff.csv")
df_sector = pd.read_csv(f"{BASE_URL}/capmff_2010-2025_sector.csv")
df_prices = pd.read_csv(f"{BASE_URL}/capmff_2010-2025_prices.csv")

# Reformatting the dataframe to multiindex panel style
prices_long = (
    df_prices
    .assign(Date=pd.to_datetime(df_prices['Date']))
    .melt(id_vars='Date', var_name='Ticker', value_name='Price')
    .dropna(subset=['Price'])
    .sort_values(['Ticker','Date'])
    .reset_index(drop=True)
)

# MultiIndex
prices_panel = prices_long.set_index(['Ticker','Date']).sort_index()

print(prices_panel.shape)

#n_obs = prices_panel.shape[0]
#n_tickers = prices_panel.index.get_level_values('Ticker').nunique()
#n_dates = prices_panel.index.get_level_values('Date').nunique()
#date_min = prices_panel.index.get_level_values('Date').min()
#date_max = prices_panel.index.get_level_values('Date').max()


industries_of_interest = ['Basic Materials', 'Communication Services', 'Consumer Cyclical', 'Consumer Defensive']
tickersOfInterest = df_sector.loc[df_sector['sector'].isin(industries_of_interest), 'Ticker'].tolist()
#print(tickersOfInterest[:20])

prices_sel = prices_panel[prices_panel.index.get_level_values('Ticker').isin(tickersOfInterest)]
#print(prices_sel.head(10))

df_returns = prices_sel.pct_change(fill_method=None).dropna()
#print(df_returns.head(450))


df_ff['Date'] = pd.to_datetime(df_ff['Date'])
rf = df_ff.set_index('Date')['RF']          


returns_df = (
    prices_sel
    .groupby(level='Ticker')           
    .pct_change(fill_method=None)
    .dropna()
    .rename(columns={'Price': 'Return'})
)


# Compute excess returns
df_ff['Date'] = pd.to_datetime(df_ff['Date'])
rf = df_ff.set_index('Date')['RF']


returns_df = returns_df.copy()
returns_df['RF'] = returns_df.index.get_level_values('Date').map(rf)
returns_df = returns_df.dropna(subset=['RF'])
returns_df['ExcessReturn'] = returns_df['Return'] - returns_df['RF']

#print(returns_df.head(450))

ff_factors = df_ff[['Date', 'Mkt-RF', 'SMB', 'HML']].copy()
ff_factors['Date'] = pd.to_datetime(ff_factors['Date'])

returns_df = (returns_df.reset_index()
              .merge(ff_factors, on='Date', how='left')
              .set_index(['Ticker','Date'])
              .dropna(subset=['Mkt-RF','SMB','HML']))  # keep only rows with factors



#Path("outputs").mkdir(exist_ok=True)
#returns_df.to_csv("outputs/returns_df.csv")


#print(f"Total observations: {n_obs:,}")
##print(f"Unique tickers:     {n_tickers}")
#print(f"Unique dates:       {n_dates}")
#print(f"Date range:         {date_min.date()} → {date_max.date()}")
#print(f"Avg. obs per firm:  {n_obs / n_firms:,.0f}")

# Data Pre-Processing
#print(df_ff.head())
#print(df_sector.head())
#print(df_prices.head())

#df_prices['Date'] = pd.to_datetime(df_prices['Date'])
#df_prices.set_index('Date', inplace=True)


#df_excess_returns = df_returns.subtract(df_ff['RF'], axis=0)

# Merge sector information
# Reset index of returns_df to access 'Date' as a column for merging
panel_data_with_sector = returns_df.reset_index().merge(
    df_sector[['Ticker', 'sector']],
    on='Ticker', # Merge on 'Ticker' column
    how='left'
)

panel_data_filtered = panel_data_with_sector.set_index(['Ticker', 'Date'])

# Filter to sectors of interest
panel_data_filtered = panel_data_filtered[
    panel_data_filtered['sector'].isin(industries_of_interest)
]
#Path("outputs").mkdir(exist_ok=True)
#panel_data_filtered.to_csv("outputs/panel_data_filtered.csv")


print("\nFinal Panel Data Info:")
print(f"Shape: {panel_data_filtered.shape}")
print(f"Unique Tickers: {panel_data_filtered.index.get_level_values('Ticker').nunique()}")
print(f"Unique Dates: {panel_data_filtered.index.get_level_values('Date').nunique()}")
print(f"Sectors: {sorted(panel_data_filtered['sector'].unique())}")
print(panel_data_filtered.head(10))

# 5. Model Estimation 
from linearmodels.panel import PanelOLS

# Model 1: Common Beta 
print("")
print("Estimating Common Beta Model:")
# Using PanelOLS with Entity Effects for α_i and common β
# NOTE: Backticks for column names with special characters
mod1_common = PanelOLS.from_formula(
    'ExcessReturn ~ 1 + EntityEffects + `Mkt-RF` + SMB + HML',
    data=panel_data_filtered
)
res1_common = mod1_common.fit(cov_type='robust')
print(res1_common)

# Hausman Test
print("\nHausman Test: Fixed Effects vs Random Effects:")

# Estimate RE model
print("Estimating Random Effects Model:")
mod1_re = RandomEffects.from_formula(
    'ExcessReturn ~ 1 + `Mkt-RF` + SMB + HML',
    data=panel_data_filtered
)
res1_re = mod1_re.fit(cov_type='robust')

# Estimate Fixed Effects model for comparison (already have res1_common)
print("Comparing Fixed Effects vs Random Effects:")

# Manual Hausman Test Implementation
def hausman_test(fe_results, re_results):
    """
    Perform Hausman test for Fixed Effects vs Random Effects
    H0: Random Effects is consistent (prefer FE + RE)
    H1: Only Fixed Effects is consistent (prefer FE)
    """
     
    # Get coefficients 
    fe_params = fe_results.params[['Mkt-RF', 'SMB', 'HML']].values
    re_params = re_results.params[['Mkt-RF', 'SMB', 'HML']].values
    
    # Covariance matrices 
    fe_cov = fe_results.cov.loc[['Mkt-RF', 'SMB', 'HML'], ['Mkt-RF', 'SMB', 'HML']].values
    re_cov = re_results.cov.loc[['Mkt-RF', 'SMB', 'HML'], ['Mkt-RF', 'SMB', 'HML']].values
    
    # Difference in coefficients
    diff = fe_params - re_params
    
    # Difference in covariance matrices
    cov_diff = fe_cov - re_cov
    
    # Hausman statistic
    hausman_stat = diff.T @ np.linalg.inv(cov_diff) @ diff
    df = len(diff)
    p_value = 1 - chi2.cdf(hausman_stat, df)
    return hausman_stat, p_value, df


# Perform Hausman test
hausman_stat, hausman_p, hausman_df = hausman_test(res1_common, res1_re)


print(f"\n--- Hausman Test Results ---")
print(f"Test Statistic: {hausman_stat:.4f}")
print(f"Degrees of Freedom: {hausman_df}")
print(f"P-value: {hausman_p:.4f}")


print("Model 2: Sector-Specific Betas")

mod2_sector = PanelOLS.from_formula(
    'ExcessReturn ~ 1 + EntityEffects + `Mkt-RF`:C(sector) + SMB:C(sector) + HML:C(sector)',
    data=panel_data_filtered,
    drop_absorbed=True 
)
res2_sector = mod2_sector.fit(cov_type='robust')
print(res2_sector)

# Difference of Betas Across Sectors
print("Wald test for difference of Betas")

def manual_wald_test(results, param_names_to_test):
   
    param_names = results.params.index.to_list()
    indices = [param_names.index(name) for name in param_names_to_test]

    R = np.zeros((len(indices), len(param_names)))
    for i, idx in enumerate(indices):
        R[i, idx] = 1

    beta_hat = results.params.values
    cov_beta = results.cov.values

    diff = R @ beta_hat
    var_diff = R @ cov_beta @ R.T

    wald_stat = diff.T @ np.linalg.inv(var_diff) @ diff
    df = len(indices)
    p_value = 1 - chi2.cdf(wald_stat, df)

    return wald_stat, p_value

param_names = res2_sector.params.index.to_list()
interaction_terms_mkt = [name for name in param_names if 'Mkt-RF:C(sector)' in name]
interaction_terms_smb = [name for name in param_names if 'SMB:C(sector)' in name]
interaction_terms_hml = [name for name in param_names if 'HML:C(sector)' in name]

if interaction_terms_mkt:
    stat_mkt, pval_mkt = manual_wald_test(res2_sector, interaction_terms_mkt)
    print(f"Mkt-RF sector betas joint test: Wald stat = {stat_mkt:.4f}, p-value = {pval_mkt:.4f}")

if interaction_terms_smb:
    stat_smb, pval_smb = manual_wald_test(res2_sector, interaction_terms_smb)
    print(f"SMB sector betas joint test: Wald stat = {stat_smb:.4f}, p-value = {pval_smb:.4f}")

if interaction_terms_hml:
    stat_hml, pval_hml = manual_wald_test(res2_sector, interaction_terms_hml)
    print(f"HML sector betas joint test: Wald stat = {stat_hml:.4f}, p-value = {pval_hml:.4f}")


all_terms = interaction_terms_mkt + interaction_terms_smb + interaction_terms_hml
if all_terms:
    stat_all, pval_all = manual_wald_test(res2_sector, all_terms)
    print(f"Overall sector betas joint test: Wald stat = {stat_all:.4f}, p-value = {pval_all:.4f}")
    alpha = 0.05
  



