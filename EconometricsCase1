# Econometrics Case 1

# Libraries
import pandas as pd
import numpy as np 
import statsmodels.api as sm
import matplotlib.pyplot as plt
from pathlib import Path



# Base URL for raw GitHub repo
BASE_URL = "https://raw.githubusercontent.com/avandersluys/EconometricsForQuantitativeFinance/main"

# Loading datasets directly from GitHub
df_ff = pd.read_csv(f"{BASE_URL}/capmff_2010-2025_ff.csv")
df_sector = pd.read_csv(f"{BASE_URL}/capmff_2010-2025_sector.csv")
df_prices = pd.read_csv(f"{BASE_URL}/capmff_2010-2025_prices.csv")

# Reformatting the dataframe to multiindex panel style
prices_long = (
    df_prices
    .assign(Date=pd.to_datetime(df_prices['Date']))
    .melt(id_vars='Date', var_name='Ticker', value_name='Price')
    .dropna(subset=['Price'])
    .sort_values(['Ticker','Date'])
    .reset_index(drop=True)
)

# Panel-style MultiIndex (Ticker, Date)
prices_panel = prices_long.set_index(['Ticker','Date']).sort_index()

print(prices_panel.shape)

#n_obs = prices_panel.shape[0]
#n_tickers = prices_panel.index.get_level_values('Ticker').nunique()
#n_dates = prices_panel.index.get_level_values('Date').nunique()
#date_min = prices_panel.index.get_level_values('Date').min()
#date_max = prices_panel.index.get_level_values('Date').max()


industries_of_interest = ['Basic Materials', 'Communication Services', 'Consumer Cyclical', 'Consumer Defensive']
tickersOfInterest = df_sector.loc[df_sector['sector'].isin(industries_of_interest), 'Ticker'].tolist()
#print(tickersOfInterest[:20])

prices_sel = prices_panel[prices_panel.index.get_level_values('Ticker').isin(tickersOfInterest)]
print(prices_sel.head(10))

df_returns = prices_sel.pct_change(fill_method=None).dropna()
print(df_returns.head(450))

# Ensure DF types/index
df_ff['Date'] = pd.to_datetime(df_ff['Date'])
rf = df_ff.set_index('Date')['RF']          # if RF is in %, do: rf = rf / 100

# Map RF onto the panel by the Date level, then compute excess returns
# ----- Compute within-ticker returns -----
# (prices_sel has MultiIndex ['Ticker','Date'] and column 'Price')
returns_df = (
    prices_sel
    .groupby(level='Ticker')           # compute pct change per ticker
    .pct_change(fill_method=None)
    .dropna()
    .rename(columns={'Price': 'Return'})
)

# ----- Align RF and compute excess returns -----
df_ff['Date'] = pd.to_datetime(df_ff['Date'])
rf = df_ff.set_index('Date')['RF']

# If RF is in percent (e.g., 0.05 for 5%), convert:
# if rf.abs().max() > 1: rf = rf / 100.0

returns_df = returns_df.copy()
returns_df['RF'] = returns_df.index.get_level_values('Date').map(rf)
returns_df = returns_df.dropna(subset=['RF'])
returns_df['ExcessReturn'] = returns_df['Return'] - returns_df['RF']

#print(returns_df.head(450))

ff_factors = df_ff[['Date', 'Mkt-RF', 'SMB', 'HML']].copy()
ff_factors['Date'] = pd.to_datetime(ff_factors['Date'])

returns_df = (returns_df.reset_index()
              .merge(ff_factors, on='Date', how='left')
              .set_index(['Ticker','Date'])
              .dropna(subset=['Mkt-RF','SMB','HML']))  # keep only rows with factors

Path("outputs").mkdir(exist_ok=True)
returns_df.to_csv("outputs/returns_df.csv")


#print(f"Total observations: {n_obs:,}")
##print(f"Unique tickers:     {n_tickers}")
#print(f"Unique dates:       {n_dates}")
#print(f"Date range:         {date_min.date()} → {date_max.date()}")
#print(f"Avg. obs per firm:  {n_obs / n_firms:,.0f}")


# Data Pre-Processing
#print(df_ff.head())
#print(df_sector.head())
#print(df_prices.head())

#df_prices['Date'] = pd.to_datetime(df_prices['Date'])
#df_prices.set_index('Date', inplace=True)


#df_excess_returns = df_returns.subtract(df_ff['RF'], axis=0)

# Merge sector information
# Reset index of returns_df to access 'Date' as a column for merging
panel_data_with_sector = returns_df.reset_index().merge(
    df_sector[['Ticker', 'sector']],
    on='Ticker', # Merge on 'Ticker' column
    how='left'
)
# Set the MultiIndex back
panel_data_filtered = panel_data_with_sector.set_index(['Ticker', 'Date'])

# Filter to sectors of interest
panel_data_filtered = panel_data_filtered[
    panel_data_filtered['sector'].isin(industries_of_interest)
]

print("\n--- Final Panel Data Info ---")
print(f"Shape: {panel_data_filtered.shape}")
print(f"Unique Tickers: {panel_data_filtered.index.get_level_values('Ticker').nunique()}")
print(f"Unique Dates: {panel_data_filtered.index.get_level_values('Date').nunique()}")
print(f"Sectors: {sorted(panel_data_filtered['sector'].unique())}")
print(panel_data_filtered.head(10))

# --- 5. Model Estimation ---
from linearmodels.panel import PanelOLS

# --- Model 1: Common Beta (Equation 1 from Assignment) ---
# y_it = α_i + f_t * β + ϵ_it
print("\n--- Estimating Model 1: Common Beta (Eq. 1) ---")
# Using PanelOLS with Entity Effects for α_i and common β
# NOTE: Backticks for column names with special characters
mod1_common = PanelOLS.from_formula(
    'ExcessReturn ~ 1 + EntityEffects + `Mkt-RF` + SMB + HML',
    data=panel_data_filtered
)
res1_common = mod1_common.fit(cov_type='robust')
print(res1_common)

# --- Model 2: Sector-Specific Betas (Equation 2 from Assignment) ---
# y_it = α_i + f_t * β_s + ϵ_it
print("\n--- Estimating Model 2: Sector-Specific Betas (Eq. 2) ---")
# Using PanelOLS with Entity Effects and interactions for β_s
# Omit main C(sector) term to avoid multicollinearity
mod2_sector = PanelOLS.from_formula(
    'ExcessReturn ~ 1 + EntityEffects + `Mkt-RF`:C(sector) + SMB:C(sector) + HML:C(sector)',
    data=panel_data_filtered,
    drop_absorbed=True # Handle potential numerical issues
)
res2_sector = mod2_sector.fit(cov_type='robust')
print(res2_sector)

# --- 6. Hypothesis Testing: Are Betas Different Across Sectors? ---
print("\n--- Testing for Differences in Betas Across Sectors ---")

import numpy as np
from scipy.stats import chi2

def manual_wald_test(results, param_names_to_test):
    """
    Perform manual Wald test for joint hypothesis that all parameters in param_names_to_test are zero.
    """
    param_names = results.params.index.to_list()

    # Validate parameter existence
    for name in param_names_to_test:
        if name not in param_names:
            raise ValueError(f"Parameter '{name}' not found in results.")

    # Indices of parameters to test
    indices = [param_names.index(name) for name in param_names_to_test]

    # Construct restriction matrix R
    R = np.zeros((len(indices), len(param_names)))
    for i, idx in enumerate(indices):
        R[i, idx] = 1

    beta_hat = results.params.values
    cov_beta = results.cov.values

    diff = R @ beta_hat
    var_diff = R @ cov_beta @ R.T

    wald_stat = diff.T @ np.linalg.inv(var_diff) @ diff
    df = len(indices)
    p_value = 1 - chi2.cdf(wald_stat, df)

    return wald_stat, p_value

# Extract relevant parameter names for each factor's sector interactions
param_names = res2_sector.params.index.to_list()
interaction_terms_mkt = [name for name in param_names if 'Mkt-RF:C(sector)' in name]
interaction_terms_smb = [name for name in param_names if 'SMB:C(sector)' in name]
interaction_terms_hml = [name for name in param_names if 'HML:C(sector)' in name]

print("\nManual Wald Tests for Equality of Sector-Specific Betas")

if interaction_terms_mkt:
    stat_mkt, pval_mkt = manual_wald_test(res2_sector, interaction_terms_mkt)
    print(f"Mkt-RF sector betas joint test: Wald stat = {stat_mkt:.4f}, p-value = {pval_mkt:.4f}")

if interaction_terms_smb:
    stat_smb, pval_smb = manual_wald_test(res2_sector, interaction_terms_smb)
    print(f"SMB sector betas joint test: Wald stat = {stat_smb:.4f}, p-value = {pval_smb:.4f}")

if interaction_terms_hml:
    stat_hml, pval_hml = manual_wald_test(res2_sector, interaction_terms_hml)
    print(f"HML sector betas joint test: Wald stat = {stat_hml:.4f}, p-value = {pval_hml:.4f}")

# Overall joint test for all sector-specific betas together
all_terms = interaction_terms_mkt + interaction_terms_smb + interaction_terms_hml
if all_terms:
    stat_all, pval_all = manual_wald_test(res2_sector, all_terms)
    print(f"Overall sector betas joint test: Wald stat = {stat_all:.4f}, p-value = {pval_all:.4f}")

    # Interpretation
    alpha = 0.05
    print("\n--- Overall Test Conclusion ---")
    if pval_all < alpha:
        print(f"Reject H0: Betas differ across sectors (p-value = {pval_all:.4f} < {alpha})")
        print("Model 2 (sector-specific betas) preferred.")
    else:
        print(f"Fail to reject H0: No strong evidence of beta differences (p-value = {pval_all:.4f} >= {alpha})")
        print("Model 1 (common beta) might suffice.")
